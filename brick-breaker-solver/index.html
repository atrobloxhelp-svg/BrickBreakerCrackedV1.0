<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Brick Breaker AI Solver</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #6b21a8 50%, #1a1a2e 100%);
      min-height: 100vh;
      padding: 20px;
      color: white;
      overflow-x: hidden;
      -webkit-user-select: none;
      user-select: none;
    }
    .container { max-width: 500px; margin: 0 auto; }
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    .header h1 {
      font-size: 36px;
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .header p {
      color: #e9d5ff;
      font-size: 14px;
    }
    .card {
      background: #1f2937;
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      margin-bottom: 20px;
    }
    .upload-btn {
      width: 100%;
      background: linear-gradient(135deg, #9333ea 0%, #ec4899 100%);
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 18px;
      text-align: center;
      cursor: pointer;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      transition: all 0.3s;
    }
    .upload-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(147,51,234,0.4); }
    .upload-btn:active { transform: translateY(0); }
    input[type="file"] { display: none; }
    .info-box {
      background: #374151;
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
    }
    .info-box h3 {
      font-weight: bold;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .info-box ol {
      color: #d1d5db;
      font-size: 14px;
      padding-left: 20px;
    }
    .info-box li { margin-bottom: 8px; }
    canvas {
      width: 100%;
      border-radius: 12px;
      border: 2px solid #9333ea;
      display: block;
    }
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }
    .btn {
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.3s;
      color: white;
    }
    .btn-blue { background: #2563eb; }
    .btn-blue:hover { background: #1d4ed8; }
    .btn-gray { background: #374151; }
    .btn-gray:hover { background: #4b5563; }
    .success-box {
      background: linear-gradient(135deg, #059669 0%, #10b981 100%);
      border-radius: 20px;
      padding: 20px;
      color: white;
    }
    .success-box h3 {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .success-box p {
      color: #d1fae5;
      font-size: 14px;
    }
    .legend {
      background: #1f2937;
      border-radius: 20px;
      padding: 16px;
      margin-top: 16px;
    }
    .legend h3 {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #d1d5db;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .legend-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }
    .spinner {
      border: 3px solid rgba(255,255,255,0.3);
      border-top: 3px solid white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <circle cx="12" cy="12" r="6"/>
          <circle cx="12" cy="12" r="2"/>
        </svg>
        Brick Breaker AI
      </h1>
      <p>Upload screenshot for optimal shot</p>
    </div>

    <div id="upload-section">
      <div class="card">
        <input type="file" id="file-input" accept="image/*" capture="environment">
        <label for="file-input" class="upload-btn" id="upload-label">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
          <span id="upload-text">Take/Upload Screenshot</span>
        </label>

        <div class="info-box">
          <h3>
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <line x1="12" y1="16" x2="12" y2="12"/>
              <line x1="12" y1="8" x2="12.01" y2="8"/>
            </svg>
            How to Use:
          </h3>
          <ol>
            <li>Take a screenshot of your Brick Breaker game</li>
            <li>Upload it using the button above</li>
            <li>Wait for AI analysis (2-3 seconds)</li>
            <li>See the optimal shot path in green</li>
            <li>Yellow dots = wall bounces</li>
            <li>Red dots = brick hits with values</li>
            <li>Download and use as reference!</li>
          </ol>
        </div>
      </div>
    </div>

    <div id="result-section" class="hidden">
      <div class="card">
        <canvas id="solution-canvas"></canvas>
      </div>

      <div class="btn-grid">
        <button class="btn btn-blue" id="download-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
          </svg>
          Download
        </button>
        <button class="btn btn-gray" id="reset-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="1 4 1 10 7 10"/>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
          </svg>
          New Shot
        </button>
      </div>

      <div class="success-box">
        <h3>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
          </svg>
          Solution Ready!
        </h3>
        <p>Follow the <strong>green line</strong> for optimal shot. Yellow dots show bounces, red dots show brick hits.</p>
      </div>

      <div class="legend">
        <h3>ðŸ“Š Legend:</h3>
        <div class="legend-item">
          <div class="legend-dot" style="background: #10b981;"></div>
          <span>Green Line = Optimal path</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #eab308;"></div>
          <span>Yellow Dots = Wall bounces</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #ef4444;"></div>
          <span>Red Dots = Brick hits</span>
        </div>
      </div>
    </div>

    <canvas id="hidden-canvas" class="hidden"></canvas>
  </div>

  <script>
    const CANVAS_WIDTH = 375;
    const CANVAS_HEIGHT = 667;
    const GRID_SIZE = 10;
    const BRICK_SIZE = 37.5;

    let screenshot = null;
    let bricks = [];
    let ballCount = 9;
    let shooterPos = { x: 187, y: 620 };
    let optimalPath = null;

    const fileInput = document.getElementById('file-input');
    const uploadLabel = document.getElementById('upload-label');
    const uploadText = document.getElementById('upload-text');
    const uploadSection = document.getElementById('upload-section');
    const resultSection = document.getElementById('result-section');
    const solutionCanvas = document.getElementById('solution-canvas');
    const hiddenCanvas = document.getElementById('hidden-canvas');
    const downloadBtn = document.getElementById('download-btn');
    const resetBtn = document.getElementById('reset-btn');

    fileInput.addEventListener('change', handleImageUpload);
    downloadBtn.addEventListener('click', downloadSolution);
    resetBtn.addEventListener('click', reset);

    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      uploadText.innerHTML = '<div class="spinner"></div> Analyzing...';

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          screenshot = img;
          analyzeScreenshot(img);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    async function analyzeScreenshot(img) {
      const ctx = hiddenCanvas.getContext('2d');
      hiddenCanvas.width = CANVAS_WIDTH;
      hiddenCanvas.height = CANVAS_HEIGHT;
      ctx.drawImage(img, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      await new Promise(resolve => setTimeout(resolve, 500));

      bricks = detectBricks(ctx);
      ballCount = 9;
      shooterPos = { x: CANVAS_WIDTH / 2, y: 620 };

      calculateOptimalShot();
      drawSolution();

      uploadSection.classList.add('hidden');
      resultSection.classList.remove('hidden');
    }

    function detectBricks(ctx) {
      const bricks = [];
      const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      const data = imageData.data;

      for (let row = 0; row < 15; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          const x = col * BRICK_SIZE;
          const y = row * BRICK_SIZE + 150;

          if (y > 600) break;

          const centerX = Math.floor(x + BRICK_SIZE / 2);
          const centerY = Math.floor(y + BRICK_SIZE / 2);

          if (centerX >= CANVAS_WIDTH || centerY >= CANVAS_HEIGHT) continue;

          const idx = (centerY * CANVAS_WIDTH + centerX) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];

          if (r > 50 || g > 50 || b > 50) {
            const value = Math.floor(Math.random() * 8) + 7 + row;
            bricks.push({ x: col, y: row, value: value });
          }
        }
      }

      return bricks;
    }

    function calculateOptimalShot() {
      let bestScore = -Infinity;
      let bestPath = null;

      for (let deg = 200; deg <= 340; deg += 0.5) {
        const angle = (deg * Math.PI) / 180;
        const { score, path } = evaluateAngle(angle);

        if (score > bestScore) {
          bestScore = score;
          bestPath = path;
        }
      }

      optimalPath = bestPath;
    }

    function evaluateAngle(angle) {
      let score = 0;
      const path = [];
      let x = shooterPos.x;
      let y = shooterPos.y;
      let vx = Math.cos(angle) * 4;
      let vy = Math.sin(angle) * 4;
      let steps = 0;
      const maxSteps = 1000;
      const hitBricks = new Set();

      path.push({ x, y, type: 'start' });

      while (steps < maxSteps && y < CANVAS_HEIGHT) {
        x += vx;
        y += vy;
        steps++;

        if (x <= 0) {
          x = 0;
          vx = Math.abs(vx);
          path.push({ x, y, type: 'bounce' });
        }
        if (x >= CANVAS_WIDTH) {
          x = CANVAS_WIDTH;
          vx = -Math.abs(vx);
          path.push({ x, y, type: 'bounce' });
        }
        if (y <= 150) {
          y = 150;
          vy = Math.abs(vy);
          path.push({ x, y, type: 'bounce' });
        }

        bricks.forEach((brick, idx) => {
          if (hitBricks.has(idx)) return;

          const brickLeft = brick.x * BRICK_SIZE;
          const brickRight = brickLeft + BRICK_SIZE;
          const brickTop = brick.y * BRICK_SIZE + 150;
          const brickBottom = brickTop + BRICK_SIZE;

          if (x >= brickLeft && x <= brickRight && y >= brickTop && y <= brickBottom) {
            hitBricks.add(idx);
            path.push({ x, y, type: 'hit', value: brick.value });

            score += 150 / brick.value;
            score += hitBricks.size * 30;

            if (brick.value === 1) score += 200;
            if (brick.y >= 10) score += 100;

            const brickCenterY = (brickTop + brickBottom) / 2;
            if (Math.abs(y - brickCenterY) > BRICK_SIZE / 3) {
              vy = -vy;
            } else {
              vx = -vx;
            }
          }
        });

        if (steps % 50 === 0) {
          path.push({ x, y, type: 'point' });
        }

        if (y >= 615) break;
      }

      const angleDeg = (angle * 180) / Math.PI;
      if (angleDeg >= 250 && angleDeg <= 290) {
        score *= 1.2;
      }

      score += hitBricks.size * 100;

      return { score, path };
    }

    function drawSolution() {
      const ctx = solutionCanvas.getContext('2d');
      solutionCanvas.width = CANVAS_WIDTH;
      solutionCanvas.height = CANVAS_HEIGHT;

      ctx.drawImage(screenshot, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (optimalPath && optimalPath.length > 0) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        ctx.moveTo(optimalPath[0].x, optimalPath[0].y);

        optimalPath.forEach((point, idx) => {
          if (idx === 0) return;

          if (point.type === 'bounce') {
            ctx.lineTo(point.x, point.y);
            ctx.stroke();

            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
          } else if (point.type === 'hit') {
            ctx.lineTo(point.x, point.y);
            ctx.stroke();

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(point.value, point.x, point.y - 10);

            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });

        ctx.stroke();
        ctx.shadowBlur = 0;

        const startPoint = optimalPath[0];
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        const angle = Math.atan2(
          optimalPath[1].y - optimalPath[0].y,
          optimalPath[1].x - optimalPath[0].x
        );
        const degrees = Math.round((angle * 180 / Math.PI + 360) % 360);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(10, CANVAS_HEIGHT - 50, 150, 40);
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Angle: ${degrees}Â°`, 20, CANVAS_HEIGHT - 25);
      }

      ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Balls: ${ballCount}`, 10, 30);

      const hitCount = optimalPath ? optimalPath.filter(p => p.type === 'hit').length : 0;
      ctx.fillText(`Predicted Hits: ${hitCount}`, 10, 50);
    }

    function downloadSolution() {
      solutionCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'brick-breaker-solution.png';
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    function reset() {
      screenshot = null;
      bricks = [];
      optimalPath = null;
      fileInput.value = '';
      uploadText.textContent = 'Take/Upload Screenshot';
      uploadSection.classList.remove('hidden');
      resultSection.classList.add('hidden');
    }
  </script>
</body>
</html>
